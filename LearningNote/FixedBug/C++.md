# Header
## 修改头文件出现的bug
#### 出现的现象
调试的时候，发现头文件中定义的结构体，依然是原有结构体

#### 原因
整体编译的时候(并未重新整体编译)，编译器有时候会略过新的头文件。

#### 解决方法
这种问题出现之后的解决方案的思想：大致都是想方法让编译器知道这个是最新的需要重新编译  
目前我实行的方法：
* 方法一：整体重新编译
  * 这样做原因：原有编译时候生成的中间文件会全部删除，然后重新生成，然后链接
  * 缺点：太耗时间(之前编译产生的汇编文件，需要重新生成)


* 方法二：首先单独编译修改的头文件，然后整体编译(非全部重新编译)
  * 这样做的原因：重新生成的中间文件，该文件的时间戳是最新的,  
    这样编译器整体编译的时候会重新编译包含该头文件的文件，然后再链接
  * 目前还没有遇到这样修改之后的问题。

# windows 下编译
使用cmd重定向， 把compile 信息 重定向到一个文件中
compile.bat > Info.txt


## windows 属性表

## 对于一个界面对象
#### 需要添加必须的接口
* 开始的时候 Init();
* 关闭的时候 UnInit();


## Qt删除多线程对象
* 一定要使用 `deleteLater()`

## 对于一个接口
### 涉及到处理数据 的 格式
* 1.异常返回
* 2.处理数据

### 涉及到 有初始值的 数据处理 的格式
* 1.初始化
* 2.处理

### Link 1104
#### 将要生成的dll爆出1104
* 原因：进程中还留有dll
* 解决：杀死带有当前dll的进程

## C2001: 常量中有换行符
* 涉及到文档的编码问题
  * 非英文字符 在windows环境下 需要使用带有BOM表的文档

* 简单解决方法：
  * 使用微软的记事本保存下

* 截图：![网络解决方法](./fixed_pic/QtError2001.png)

## 对于不能及时销毁的数据，存储方法：
#### 单独存储
* 与界面无关
* 所有界面的操作类似于 view/model 展示逻辑
* 这样做的好处：
  * 数据界面分离
  * 数据可以有多种展示

#### 与界面绑定存储
* 在界面对象中
* 如果需要保证 界面关闭后 数据依然存在 的两种直接简单的方法
  * 数据本身使用堆内存
  * 界面对象使用堆
* 这样做的好处:
  * 所见即所得

## 调试平台相关数据
#### 1. 对比两个平台之间是否有数据迥异的问题

#### 2. 抓包：抓取是否本机获取异常

#### 3. 查找本机获取数据代码，以及处理数据代码

#### 通常情况：3 --> 1 --> 2
#### 也可以 ： 2 --> 3 
