# JS
---
---
## 注释
### `/* */` 块注释
### `//` 行注释

## 数字
只有一个数字类型
* 内部被表示为64位浮点数
* 负数使用前置运算符
  * `-1`
* NaN是一个数值，它表示一个不能产生正常结果的运算结果。
  * NaN不等于任何值，包括它自己
  * isNaN(number) 检测NaN
* Infinity表示所有大于1.79769313486231570e+308的值
* 数字拥有方法
  * 有个对象Math，它包含作用于数字的方法

## 字符串
字符串字面量可以被包在一对单引号或双引号中它可能包含0个或多个字符
* `\`是转义字符
* JS在被创建的时候，Unicode是一个16位的字符集，所以JS的所有字符都是16位的
* JS没有字符类型
  * 若要表示一个字符，只需创建仅包含一个字符的字符串即可

## 语句
* JS没有新的作用域，所以变量应该被定义在函数头部，而不是代码块中

* 被判断为假的值
  * false
  * null
  * undefined
  * 空字符串 ' '
  * 数字 0
  * 数字 NaN

### 运算符优先级
* ` . [] ()`
* `delete new typedef + - !`
* `* / %`
* `+ -`
* `>= <= > <`
* ` === !===`
* ` && `
* ` || `
* ` ? :`

---
## 函数
### 函数是第一型对象
* 通过字面量进行创建
* 可赋值给变量、数组火其他对象的属性
* 可作为参数传递给函数
* 可作为函数的返回值进行返回
* 可拥有动态创建并赋值的属性


* 还能调用~~~~

### 如何声明
* function 关键字
* 可选名称
* 参数列表
* 函数体

#### 函数声明还有什么？
* name 属性

### 调用方式
* 作为一个函数进行调用
* 作为一个方法进行调用，在对象上进行调用
* 作为构造器进行调用
*  通过 call() / apply() 进行调用
####  调用方式的主要差异
作为this参数传递给执行函数的上下文对象之间的区别
* 作为方法调用， 上下文是方法的拥有者
* 作为全局函数进行调用， 上下文永远 是  window
* 作为构造器进行调用， 上下文 是 新创建的 对象实例



### 参数与函数形参
所有函数 调用 都会传递 两个隐式参数   arguments this
#### 当 参数 数量 > 函数声明 的 形参数量
* 超出的参数不会配给形参

#### 当 参数 数量 < 函数声明 的 形参数量
*  没有 对应的 参数， 形参会赋值为 undefined

#### arguments 参数
* 是 传递给函数的 所有参数的 集合
* 有length 属性
* 可以像访问数组索引一样 获取 参数值

#### this  参数
* 叫 调用上下文？

### 构造器
#### 行为 发生
* 1 创建一个新的空的对象
* 2 传递给构造器 的对象是 this  参数， 从而成为构造器的函数上下文
* 3 如果没有显式返回值，新创建的对象则作为构造器的返回值进行 返回

### apply() /  call()

---
## 使用函数
### 匿名函数
#### 引用的丢失问题
#### callee 属性
#### 伪造数组？

### 可变长度的参数列表
#### 使用apply（）支持可变参数
* apply 传递的是一个数组

### 函数重载
* 只有一个实现
* 通过传入参数的特性和个数进行相应修改

#### 参数
* 函数的 length 可以知道 声明了多少明明参数
* arguments.lenth 可以知道在调用时传了多少参数

#### 如何重载
* 通用的方法： 根据传入参数的类型执行不同的操作
* 通过特定参数是否存在来进行判断
* 通过传入参数的个数进行判断

#### 函数判断
* 一般 typeof

### for in
* 遍历对象的所有属性
---
## 闭包
### 是什么
* closure 是作用域
* 是一个函数创建时，能够允许自己访问并操作自己函数之外的变量时的作用域
* 闭包可以让函数访问所有的变量和函数，只要变量和函数存在于 该函数声明时的作用域就行
* 声明的函数在后续什么时候都可以被调用，即便声明时的作用域消失之后

### 如何使用
#### 私有变量
* 封装一些私有变量 限制这些变量的作用域
