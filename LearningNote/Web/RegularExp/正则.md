#  正则表达式
## 正则作用
* 搜索
* 替换

## 什么是正则
* 用来 匹配和处理文本的字符串 的语言
---
## 匹配单个字符
### 匹配纯文本
* 字符本身

### 匹配任意字符
`.`可以匹配任何一个单个的字符
* `.`字符可以匹配任何单个字符、字幕、数字甚至是`.`字符本身

#### 注意
* 正则表达式可以用来匹配包含着字符串内容的模式
* 匹配的并不总是整个字符串，而是与某个模式相匹配的字符
---
## 匹配一组字符
### 匹配多个字符中的某一个
`[]`负责定义一个字符集合，自己不匹配任何字符
* 在搜索不需要大小写字母的操作中常常使用

### 取非匹配 `^`
给出一组不需要的得到的字符，换句话说，出了那个字符集合里的字符，其他字符都可以匹配

## 元字符
### 对特殊字符进行转义 `\`
### 匹配空白字符
```
[\b] : 回退(并删除)一个字符
\f  :  换页符
\n  :  换行符
\r  :  回车符
\t  :  制表符
\v  :  垂直制表符
```

### 匹配特定的字符类别
```
1. 匹配数字(与非数字)
\d  :  任何一个数字字符(等价于[0-9])
\D  :  任何一个非数字字符(等价于[^0-9])

2. 匹配字母和数字(与非字母和数字)
\w  :  任何一个字母数字字符(大小写均可)或下划线字符(等价于[a-zA-Z0-9_])
\W  :  任何一个非字母数字或下划线字符(等价于[^a-zA-Z0-9_])

3. 匹配空白字符
\s  :  任何一个空白字符(等价于[\f\n\r\t\v])
\S  :  任何一个非空白字符(等价于[^\f\n\r\t\v])


3. 匹配八进制或十六进制数值
\x  :  前缀\x匹配十六进制
\0  :  前缀\0匹配八进制
```
---
## 重复匹配
### 匹配一个或多个字符 `+`
在想要匹配的字符(或字符集合)加上+字符作为后缀就行

### 匹配零个或多个字符 `*`
匹配一个可有可无的字符？

### 匹配零个或一个字符 `?`
只能匹配一个字符的零次或一次

### 精确匹配重复次数 `{}`
* 在`{}`之间填入数字即可

#### 为重复匹配次数设定一个区间
如`{2, 4}`  最少2次最多4次

### 至少匹配多少次 `{N, }`

### 防止过度匹配
```
贪婪型元字符   懒惰型元字符
    *             *？
    +             +？
    {n, }         {n, }?
```
---
## 位置匹配
### 单词边界 `\b`
#### `\b`用来匹配一个单词的开始或结尾
#### 匹配一个完整的单词
`\bcap\b`匹配cap这个单词
* `\b`匹配一个位置：这个位置位于构成单词的字符和一个不能用来构成单词的字符之间
* 构成单词的字符：字母、数字和下划线  -> `\w`
* 不能用来构成单词的字符  ->  `\W`

#### 注意
`\b`匹配且只匹配一个位置，不匹配任何字符

#### `\B` 不匹配一个单词边界

### 字符串边界
#### 字符串开头 `^`
#### 字符串结尾 `$`

---
## 使用子表达式
### 子表达式
* 子表达式是一个更大的表达式的一部分
* 划分之后的子表达式可以被当作一个独立元素来使用
* 子表达式必须用（和）括起来

#### 注意：
（和）都是元字符，如果要匹配（和）本身，就必须使用它的转义序列`\( 和 \)`

`(\d{1,3}\.){3}\d{1,3}`

### 子表达式的嵌套
理论上没有任何限制

#### 注意
写出个匹配结果符合预期的很容易，但是把不符合预期的差集排除很难

```
匹配一个IP：
1. 最初思路
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
2. 浓缩个子表达式
(\d{1,3}\.){3}\d{1,3}

此时：超过255的不是IP的数值也会匹配

归纳IP的数值字符规则：
1. 任何一个 1位 或 2位 数字
2. 任何一个 以 1开头的 3位数字
3. 任何一个 以 2开头的、 第2位数字 小于5(数值匹配来说：0~4)的 3位数字
4. 任何一个 以 25开头的、第3位数字 小与6(数值匹配来说：0~5)

写：
1. -> (\d{1,2})
2. -> (1\d{2})
3. -> (2[0-4]\d)
4. -> (25[0-5])

合并：
(25[0-5])|(2[0-4]\d)|(1\d{2})|(\d{1,2})

将上式带入替换
(
  (
    (25[0-5])
    |(2[0-4]\d)
    |(1\d{2})
    |(\d{1,2})
  )
  \.
)
{3}
(
  (25[0-5])
  |(2[0-4]\d)
  |(1\d{2})|
  (\d{1,2})
)

```
---
## 回溯引用：前后一致性匹配
#### 回溯引用匹配 `\1`
#### 注意
* 回溯引用指的是模式的后半部分引用在前半部分中定义的子表达式
* 可以当成变量
* 回溯只能引用模式里的子表达式（用括号括起来的正则表达式片段）

#### 大小写转换 --替换模式
```
\E    结束\L或\U转换
\l    把下一个字符转换为小写
\L    把\L到\E之间的字符转换为小写
\u    把下一个字符转换为大写
\U    把\L到\E之间的字符转换为大写
```
---
## 前后查找
#### 向前查找
从语法上看，一个向前查找模式其实就是一个以`?=`开头的子表达式，需要匹配的文本跟在`=`后面

* 向前查找的意思大概是设定一个断点，断点的位置就是`=`后面的内容的首个字符(从数轴来讲，类似于假如=后面写的3，则我们在集合中写的就是<3,不包括3的意思)，具体举例：

```
字符串： 012345678
使用正则：\d+(?=4)      显示：0123
使用正则：\d+(?=45)     显示：0123
使用正则：\d+(?=456)    显示：0123
使用正则：(?=4)\d+      显示：456789
使用正则：(?=45)\d+     显示：456789
使用正则：(?=456)\d+    显示：456789

```

* 从左到右看的话，就是开始匹配，到向前查找表达式之前。
* 向前表达式，到结束


#### 向后查找
以`?<=`开头的子表达式，需要匹配的文本跟在`=`后面

* 从表现上与向前查找相反
* 而且向后查找的模式是固定长度

#### 对向前向后查找取非
```
(?=)      正向前
(?!)      负向前
(?<=)     正向后
(?<!)     负向后
```

---
## 嵌入条件
#### 总结下之前 `?`的用法
* `?`匹配前一个字符或表达式。如果它存在的话
* `?=`和`?<=` 匹配前面或后面的文本，如果它存在的话

#### 回溯引用条件
* 语法:`(?(backreference)true-regex)`
  * if do


* 语法:`(?(backreference)ftrue-regex|false-regex)`
  * if do else do
