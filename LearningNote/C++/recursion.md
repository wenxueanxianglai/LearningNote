# 关于递归的一些思考：
## 递归：调用自己
* 这个定义是从运行状态来定义的。

## 仅从做的事情的角度看下递归：
* 所有做的事情的步骤都是一样的。
* 有个初始步骤，这样可以有个出口
* 从这里看的话，我们往往建模都会向数列方向去靠。
  * 数列有一个初始值
  * 数列有个针对于 An -> An+1的一个关系表达式
* 遍历看起来也是这样，里面做的事情的步骤是一样的，有一个初始步骤
* 所以，如果从做事的角度来看的话，遍历和递归是一样的。

## 关于递归思考转换成代码
* 如果当前已经建模成最简单的数学表达式。诸如递推，斐波那契之类的。直接就能成为代码
* 如果是稍微复杂点的步骤，看到学弟已经晕了，这时候一定要分而治之，找到每次做事情不变的地方
  * 最简单直观的 ，相对于当前这一件事情不变的， 如果是for循环，就是那个i
  * 如果是递归，那就是那个栈是不变的，我们去看怎么返回的，就能知道哪个往往是不变的。

## 小栗子：
输出某个自然数之前的所有排列顺序。  
诸如N = 1, 输出： 1
N = 2, 输出： 1 2； 2 1
N = 3, 输出： 1 2 3； 1 3 2； 213； 231； 312； 321；

#### 分析
* 对于上述例子，我们很容易想到最简单的高中排列组合学到的排列。   

回想下：当时我们学习排列的时候怎么学习的？ 我当时学习的是：有一堆小球在地上,小球有编号，  
这边有槽，我们把球放到槽里，有多少种放的方式？   

当时并没有学公式，只是自己依次试出来，然后统计。   
尝试的步骤：
* 步骤 1：把一个球 拿过来，放到左边第一个槽，（一般都会拿编号1的球，至于为什么放左边，我是左撇子）
* 重复步骤1：放到下一个槽，直到放完
* 写出这个排列
* 我一般从最尾巴交换两个球。
* 写出这个排列  


这时候看起来似乎有点重复，但是我们知道计算机里的交换是两个瓶子交换里面水的问题，需要第三个瓶子。  
如果这时候把原来放球的地方，当成第三个瓶子，这时候，尾巴的两个球，以及空地就形成了交换。  

具体点：  
* 步骤 1：把一个球 拿过来，放到左边第一个槽
* 重复步骤1，直到放完
* 写出这个排列
* 从右边数，第一个球，拿出一个球
* 从右边数，第一个球，拿出一个球
* 拿一个球过来，然后放到左边...

再找找规律：
* 如果从左边数，槽上有位置，则把球放进去，不断重复
* 如果都放置完，则从右边拿出相应的球，继续上述步骤。  

当然上面还有隐含条件：每次排列不能重复，每个球只能放在一个槽里。
这保证了，如果我们排序过之前的的序列，之后就不能排序了。

甚至更向上抽象：
* 每个槽都是在剩下的球里挑选一个，然后，放进去自己的槽里
* 每个槽每次挑选的球不能和原来的相同

```C++
//从槽的观点去写
int flag[100];
int slot[100];
int ball = 50;


void SetBall(int OneSlot) {
  if (OneSlot == ball) {
    //print array of slot
  }
  else
  {
    for (size_t i = 0; i < ball; i++) {
       if (flag[i] == 0) {
         flag[i] = 1;
         slot[OneSlot] = i + 1;

         SetBall(OneSlot);
         flag[i] = 0;
       }
    }
  }



}


```
