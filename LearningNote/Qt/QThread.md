# 进程和线程的概念
---
## 进程
### 程序是计算机及存储系统中的数据文件
#### 源代码程序
* 文本文件，描述程序行为和功能

#### 可执行程序
* 二进制文件，直接加载并执行

### 进程的概念
#### 广义概念
* 程序中关于某个数据集合的一次运行活动

#### 狭义概念
* 程序被加载到内存中执行后得到进程

### 进程和线程区别
#### 程序和硬盘中静态的文件
* 存储系统中的一段二进制表示

#### 进程是内存中动态地运行实体
* 数据段，代码段，PC指针，等

### 程序和进程的联系
#### 一个程序可能对应多个进程
* 一个程序多次运行，每个运行产生一个进程

#### 一个进程可能包含多个程序
* 一个程序依赖多个其他动态库

#### * Notice *
当代操作系统中，资源分配的基本单位是进程，而CPU调度执行的基本单位是线程！

---
## 线程
### 线程的概念
* 进程内的一个执行单元
* 操作系统中的一个可调度的实体
* 进程中相对独立的控制流序列
* 执行时的现场数据和其他调度所需的信息

### 再论main函数
C/C++程序被执行后从main函数开始运行，那么这中间经历了什么样的过程？
#### 可执行程序加载执行步骤
* 1. 系统分配资源（内存，IO，等）
* 2. 将PC指向main函数入口地址
* 3. 从PC指针包含的地址处开始执行(第一个线程)

**线程是进程使用CPU资源的基本单位**

### 深入理解进程和线程
* 进程中可以存在 **多个线程** 共享进程资源
* 线程是被调度的执行单元，而   **进程不是调度单元**
* **线程不能脱离进程单独存在**，只能依赖于进程进行
* 线程有生命期，有诞生和死亡
* 任意线程都可以创建其他新的线程
---
---
# Qt中的多线程编程
---
## Qt 中通过QThread直接支持多线程
* QThread 是一个跨平台的多线程解决方案
* QThread 以简洁易用的方式实现多线程编程

#### 注意：
* Qt中的线程 **以对象的形式** 被创建和使用
* 每一个线程对应着一个 QThread 对象

## QThread 中的关键成员函数
#### void run()
线程体函数，用于定义线程功能(执行流)

#### void start()
启动函数，将线程入口地址设置为run函数

#### void terminate()
强制结束线程(**不推荐**)

---
---
# 多线程间的同步
---
## 多线程的本质是什么？
* **并发性** 是多线程编程的本质
* 在宏观上，所有线程并行执行
* 多个线程间 **相对独立**，互不干涉

## 问题：线程间总是完全独立毫无依赖的吗？
* 在特殊情况下，多线程的执行在时序上存在依赖性


## 同步的概念
* 在特殊情况下，控制多线程间的相对执行顺序

## QThread 类直接支持线程间的同步
```C++
bool QThread::wait(unsigned long time = ULONG_MAX)

QThread t;
t.start(); //创建并启动子线程
t.wait(); //等待子线程并执行结束

```

## 小结
* 在默认情况下，各个线程独立存在，并行执行
* 在特殊情况下，多线程的执行存在时序上的依赖
* QThread 类直接支持线程间的同步(wait()成员函数)
* wait()停止当前线程的执行，等待目标线程执行结束



---
---
# 多线程间的互斥(上)
---
## 值得思考的问题
#### 多个线程间除了在时序上可能产生依赖，在其他方面是否也能产生依赖？
#### 生产消费者问题
* 有n个 **生产者** 同事制造产品，并把产品存入仓库中
* 有m个 **消费者** 同事需要从仓库中取出产品
* 规则
  * **当仓库未满**， 任意生产者可以存入产品
  * **当仓库未空**， 任意消费者可以取出产品

## 基础概念
#### 临界资源(Critical Resource)
* 每次只允许一个线程进行访问(读/写)的资源

#### 线程间的互斥(竞争)
* 多个线程在同一时刻都需要访问临界资源

#### QMutex 类 是一把线程锁，保证线程间的互斥
* 利用线程锁能够保证临街资源的安全性

#### QMutex 中的关键成员函数
* void lock()
  * 当锁空闲时，获取锁并继续执行
  * 当锁被获取，阻塞并等待锁释放


* void unlock()
  * 释放锁(同一把锁的获取和释放锁必须在同一线程中成对出现)

#### QMutex使用实例
```C++
QMutex mutex;

mutex.lock();

// do something with critical resource

mutex.unlock();
```
#### 注意：
如果mutex在调用unlock()处于空闲状态，那么程序的行为是 **未定义的**！！！

## 小结
* 临街资源每次 **只允许一个线程** 进行访问(读/写)
* 线程锁(QMutex)用于保护临界资源
* 线程只有获取锁之后才能访问临界资源
* 锁被其他线程获取时，当前线程进入等待状态
* 线程锁的获取和释放必须在 **同一线程中成对出现**


---
---
# 多线程间的互斥(下)
---
## 问题
程序有多少临界资源？需要多少个线程锁？

## 一般性原则
每个临界资源都需要一个线程锁进行保护！

## 线程的 死锁 概念
* 线程间相互等待临界资源而造成彼此无法继续执行

## 发生死锁的条件
* 系统中存在多个临界资源 且 **临界资源不可抢占**
* 线程需要多个临界资源才能继续执行

## 死锁的避免
* 对所有的临界资源都分配一个唯一的序号
* 对应的线程锁也分配同样的序号
* 系统中的每个线程 **必须严格递增的次序** 请求资源！

## 信号量的概念
* 信号量是 **特殊的** 线程锁
* 信号量允许 **N个线程同时** 访问临界资源
* Qt中直接支持信号量(QSemaphore)

## Qsemaphore 使用示例
* QSemaphore 对象维护了一个整型值
* acquire()使得该值减1, release()使得该值加1
* 当该值为0时，acquire()函数将阻塞当前线程

## 小结
* 多线程间相互等待临街资源将导致死锁
* 可以对临街资源进行编号的方法避免死锁
* 所有线程必须按照严格递增的次序请求资源
* Qt中直接支持信号量(QSemaphore)
* 信号量允许N个线程同时访问临界资源















0
