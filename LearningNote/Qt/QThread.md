# 进程和线程的概念
---
## 进程
### 程序是计算机及存储系统中的数据文件
#### 源代码程序
* 文本文件，描述程序行为和功能

#### 可执行程序
* 二进制文件，直接加载并执行

### 进程的概念
#### 广义概念
* 程序中关于某个数据集合的一次运行活动

#### 狭义概念
* 程序被加载到内存中执行后得到进程

### 进程和线程区别            现在          
#### 程序和硬盘中静态的文件
* 存储系统中的一段二进制表示

#### 进程是内存中动态地运行实体
* 数据段，代码段，PC指针，等

### 程序和进程的联系
#### 一个程序可能对应多个进程
* 一个程序多次运行，每个运行产生一个进程

#### 一个进程可能包含多个程序
* 一个程序依赖多个其他动态库

#### * Notice *
当代操作系统中，资源分配的基本单位是进程，而CPU调度执行的基本单位是线程！

---
## 线程
### 线程的概念
* 进程内的一个执行单元
* 操作系统中的一个可调度的实体
* 进程中相对独立的控制流序列
* 执行时的现场数据和其他调度所需的信息

### 再论main函数
C/C++程序被执行后从main函数开始运行，那么这中间经历了什么样的过程？
#### 可执行程序加载执行步骤
* 1. 系统分配资源（内存，IO，等）
* 2. 将PC指向main函数入口地址
* 3. 从PC指针包含的地址处开始执行(第一个线程)

**线程是进程使用CPU资源的基本单位**

### 深入理解进程和线程
* 进程中可以存在 **多个线程** 共享进程资源
* 线程是被调度的执行单元，而   **进程不是调度单元**
* **线程不能脱离进程单独存在**，只能依赖于进程进行
* 线程有生命期，有诞生和死亡
* 任意线程都可以创建其他新的线程
---
---
# Qt中的多线程编程
---
## Qt 中通过QThread直接支持多线程
* QThread 是一个跨平台的多线程解决方案
* QThread 以简洁易用的方式实现多线程编程

#### 注意：
* Qt中的线程 **以对象的形式** 被创建和使用
* 每一个线程对应着一个 QThread 对象

## QThread 中的关键成员函数
#### void run()
线程体函数，用于定义线程功能(执行流)

#### void start()
启动函数，将线程入口地址设置为run函数

#### void terminate()
强制结束线程(**不推荐**)

---
---
# 多线程间的同步
---
## 多线程的本质是什么？
* **并发性** 是多线程编程的本质
* 在宏观上，所有线程并行执行
* 多个线程间 **相对独立**，互不干涉

## 问题：线程间总是完全独立毫无依赖的吗？
* 在特殊情况下，多线程的执行在时序上存在依赖性


## 同步的概念
* 在特殊情况下，控制多线程间的相对执行顺序

## QThread 类直接支持线程间的同步
```C++
bool QThread::wait(unsigned long time = ULONG_MAX)

QThread t;
t.start(); //创建并启动子线程
t.wait(); //等待子线程并执行结束

```

## 小结
* 在默认情况下，各个线程独立存在，并行执行
* 在特殊情况下，多线程的执行存在时序上的依赖
* QThread 类直接支持线程间的同步(wait()成员函数)
* wait()停止当前线程的执行，等待目标线程执行结束



---
---
# 多线程间的互斥(上)
---
## 值得思考的问题
#### 多个线程间除了在时序上可能产生依赖，在其他方面是否也能产生依赖？
#### 生产消费者问题
* 有n个 **生产者** 同事制造产品，并把产品存入仓库中
* 有m个 **消费者** 同事需要从仓库中取出产品
* 规则
  * **当仓库未满**， 任意生产者可以存入产品
  * **当仓库未空**， 任意消费者可以取出产品

## 基础概念
#### 临界资源(Critical Resource)
* 每次只允许一个线程进行访问(读/写)的资源

#### 线程间的互斥(竞争)
* 多个线程在同一时刻都需要访问临界资源

#### QMutex 类 是一把线程锁，保证线程间的互斥
* 利用线程锁能够保证临街资源的安全性

#### QMutex 中的关键成员函数
* void lock()
  * 当锁空闲时，获取锁并继续执行
  * 当锁被获取，阻塞并等待锁释放


* void unlock()
  * 释放锁(同一把锁的获取和释放锁必须在同一线程中成对出现)

#### QMutex使用实例
```C++
QMutex mutex;

mutex.lock();

// do something with critical resource

mutex.unlock();
```
#### 注意：
如果mutex在调用unlock()处于空闲状态，那么程序的行为是 **未定义的**！！！

## 小结
* 临街资源每次 **只允许一个线程** 进行访问(读/写)
* 线程锁(QMutex)用于保护临界资源
* 线程只有获取锁之后才能访问临界资源
* 锁被其他线程获取时，当前线程进入等待状态
* 线程锁的获取和释放必须在 **同一线程中成对出现**


---
---
# 多线程间的互斥(下)
---
## 问题
程序有多少临界资源？需要多少个线程锁？

## 一般性原则
每个临界资源都需要一个线程锁进行保护！

## 线程的 死锁 概念
* 线程间相互等待临界资源而造成彼此无法继续执行

## 发生死锁的条件
* 系统中存在多个临界资源 且 **临界资源不可抢占**
* 线程需要多个临界资源才能继续执行

## 死锁的避免
* 对所有的临界资源都分配一个唯一的序号
* 对应的线程锁也分配同样的序号
* 系统中的每个线程 **必须严格递增的次序** 请求资源！

## 信号量的概念
* 信号量是 **特殊的** 线程锁
* 信号量允许 **N个线程同时** 访问临界资源
* Qt中直接支持信号量(QSemaphore)

## Qsemaphore 使用示例
* QSemaphore 对象维护了一个整型值
* acquire()使得该值减1, release()使得该值加1
* 当该值为0时，acquire()函数将阻塞当前线程

## 小结
* 多线程间相互等待临街资源将导致死锁
* 可以对临街资源进行编号的方法避免死锁
* 所有线程必须按照严格递增的次序请求资源
* Qt中直接支持信号量(QSemaphore)
* 信号量允许N个线程同时访问临界资源


---
---
# 银行家算法的分析与实现
---
## 问题描述
* 研究一个银行家如何将总数一定的资金， **安全地** 若干个顾客，
* 使 顾客 **既能满足对资金的需求**
* 也使 银行家 **可以收回自己的全部资金，不至于破产**

## 一些限制条件
* 每个顾客在借款前 **必须提前说明所需资金总额**
* 每次借钱都是 **一个单位进行** (如：一个单位为1万人民币)
* 顾客在拿到一个单位的借款前可能需要等待
* 银行保证顾客的 **等待时间是有限的***(借或不借)

## 算法策略
* 将资金 **优先借给资金需求较少的客户**

## 应用场景
* 操作系统内核中的进程管理
* 数据库内核中的频繁事物管理

## Qt的算法实现方案
* 使用 **多线程机制模拟** 客户和银行
* 银行优先分配资源给 **最小需求** 的客户
* 当客户的资源需求无法满足的时候
  * 收回已分配的资源
  * 强制结束线程

---
---
# 多线程中的信号与槽(上)
## QThread类拥有发射信号和定义槽函数的能力
* 关键信号
  * void started() : 线程 **开始运行时** 发射该信号
  * void finished() : 线程 **完成运行时** 发射该信号
  * void terminated() : 线程被 **异常终止时** 发射信号

## 让人逃避的问题
* 如果程序中有多个线程，槽函数是在哪个线程中执行的？

## 概念小科普
* 进程存在栈空间的概念
* 栈空间专用于函数调用(保存函数参数，局部变量，等)
* 线程拥抱有独立的站空间(可调用其他函数)

## 小结论
只要函数体中没有访问临界资源的代码，同一个函数可以被多个线程同时调用  
且不会产生任何副作用！


## 实验前的准备
#### 操作系统通过整形标识管理进程和线程
* 进程拥有全局唯一的ID值(PID)
* 线程有进程内唯一的ID值(TID)

#### QThread 中的关键静态成员函数
* QThread* currentThread()
* Qt::HANDLE currentThreadID()

## 小结
* QThread类拥有发射信号和定义槽函数的能力
* 线程在进程内拥有一个 **唯一的ID值**
* 线程拥有独立的栈空间用于函数调用
* 没有临界资源的函数可以无副作用的被多个线程调用
* 槽函数的调用在某一个线程中完成


# 多线程中的信号与槽(中)
## 对象依附于哪一个线程？
  默认情况下，对象依附于自身被创建的线程

## 对象的依附性与槽函数执行的关系？
默认情况下，槽函数在其所衣服的线程中被调用执行！

## 对象的依附性是否可以改变？
 ** QObject::moveToThread用于改变对象的线程依附性，使得对象的槽函数在依附的线程中被调用执行

## 线程中的事件循环
* 信号与槽的机制需要事件循环的支持
* QThread 类中提供的exec()函数用于开启线程的事件循环
* 只有事件循环开启，槽函数才能在信号发送后被调用

## 小结论
* 前提条件
  * 对象依附的线程开启了事件循环


* 后置结果
  * 对象中的槽函数在依附的线程中被调用执行
  





















0
